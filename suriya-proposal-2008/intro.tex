% $Id: intro.tex 8162 2008-06-17 15:51:25Z suriya $

\section{Introduction}

\paragraph{Problem}
Software is imperfect.  To fix bugs and adapt software to the changing
needs of users, developers must modify deployed systems.  However,
halting a software system to apply updates creates new problems:
safety concerns for mission-critical and transportation systems;
substantial revenue losses for
businesses~\cite{gartner98downtime,roc1}; maintenance
costs~\cite{zorn05}; and at the least, inconvenience for users, which
can translate into a serious security risk if patches are not applied
promptly~\cite{altekar05opus,Ksplice}.  Dynamic software updating (DSU)
addresses these problems by updating programs while they run. DSU is
appealing because it is general-purpose: it requires no
special software architecture and neither extra nor redundant hardware~\cite{kspliceslashdot08}. The
challenge is to make DSU 
\emph{safe} enough that updating a program is as correct as
deploying it from scratch, \emph{flexible} enough that it can support
software updates that are likely to occur in practice, and
\emph{efficient} enough to have little or no impact on application
performance.

Researchers have made significant strides toward making DSU practical
for systems written in C and C++, supporting server feature
upgrades~\cite{neamtiu06dsu,chen:icse07}, security
patches~\cite{altekar05opus}, and operating systems
upgrades~\cite{K42reconfig,k42usenix,dynamos_eurosys_07,chen06vee,Ksplice}.
Because enterprise
systems and embedded systems---including safety-critical
applications---are increasingly written in languages such as
Java and C\#, these languages would benefit from DSU support.
Unfortunately, work on DSU for these languages lags behind work for
C and C++.  For example, while the HotSpot JVM~\cite{JVMhotswap} and
several .NET languages~\cite{VSEnC} support on-the-fly method body
updates, this support is too inflexible for all but the simplest
updates---less than half of the changes in three Java benchmark programs we
examined could be supported.  Other approaches proposed in
the literature~\cite{ritzau00dynamic,Mala00a,orso:java} are
flexible but impose substantial a priori space and time overheads and
have not been proven on realistic applications.

\paragraph{Solution}
This proposal presents the design and implementation of a dynamic
updating system called \DSU{} that we have built into \JikesRVM{}, a
Java Research Virtual Machine.  The key contribution is to show that
modest extensions to existing VM services naturally support DSU that
is flexible, safe, and imposes no a priori space or time overheads.

\DSU{} DSU support is quite flexible.  Dynamic updates may add new
classes or change existing ones.  A change to a class may add new
fields and methods, or replacing existing ones, and these replacements
may have different type signatures.  Changes may occur at any level of
the class hierarchy.  To initialize new fields and update
existing ones, \DSU{} applies \emph{class} and \emph{object
  transformer} functions, the former for static fields and the latter
for instance fields.  A default transformer is automatically generated by
the system at runtime---it initializes new and changed fields to a default value,
and retains the values of unchanged fields. The user may instead provide a
custom transformer.

\DSU{} loads new and updated classes into a running program via the
standard class loading facility.  \DSU{} triggers compilation of the
modified classes and invalidates existing compiled code for modified and
\emph{transitively-modified} methods, which are those methods that
rely on the prior method's representation, such as methods in which the \acs{JIT}
previously inlined the modified methods. The \acf{JIT} compiler then
naturally recompiles each invalidated method when the program next
tries to execute it, just as it would for a newly-loaded method.
When a dynamic update to a class changes its instance fields, \DSU{}
piggybacks on top of a whole-heap \acf{GC} to find and transform existing
instances of that class.  When the collector first encounters such
an object, it creates a new object corresponding to the new class
definition.  At the conclusion of GC, \DSU{} applies the
object and class transformers to initialize the new objects' fields
and static class fields, respectively.

\DSU{} imposes no overhead during normal execution.  The class 
loading, recompilation, and garbage collection modifications of \DSU's
VM-based DSU support are modest and their overheads are only imposed
during an update, which is a rare occurrence.  The zero overhead for a
VM-based approach is in contrast to DSU techniques typical of C and C++
that, for example, use 
a compiler or dynamic rewriter to insert levels of
indirection~\cite{neamtiu06dsu, orso:java} or
trampolines~\cite{chen06vee,chen:icse07,altekar05opus,Ksplice}, respectively,
which affect performance during normal execution.  VMs also have the
advantage of better memory management support.  Rather than requiring
each allocation to pad objects in case they become larger due to an
update~\cite{neamtiu06dsu}, managed languages have the flexibility to
copy objects, and thus grow them only if necessary.

\DSU{} piggybacks on normal bytecode verification, part of
classloading, to ensure that updated classes are type-safe.  To avoid
type errors that could result due to the timing of an
update~\cite{neamtiu06dsu,k42usenix}, \DSU{} only permits updates to
take place at a \emph{safe point}.  Such a point occurs when no
running thread's activation stack refers to (1) an updated class, or
(2) any class that either inlines an updated class or calls a
method of an updated class whose signature has changed.  Both parts of
condition (2) are to handle changes in representation due to
recompilation.  This safety condition is similar to conditions proposed
in prior work~\cite{StoyleHBSN06,boyapati03lazy}, but is comparably much
simpler, and accepts the large majority of updates we considered.

To assess \DSU{}, we used it to apply one to two years' worth of the
changes corresponding to releases of three open-source applications:
Jetty web server, JavaEmailServer (an SMTP and POP server), and
CrossFTP server.  \DSU{} could successfully apply 20 of the 22
updates---the two updates it could not apply changed classes with
infinitely-running methods, and thus no safe point could be reached.
We plan to leverage VM on-stack replacement facilities to update
active methods in future work.  Performance experiments with Jetty confirm
that applications updated by \DSU{} enjoy the same performance as those started from
scratch, except during the update itself.  Microbenchmark results show
that the pause time due to an update depends on the size of the heap
and fraction of objects that must be transformed.  We find there is a
high per-object cost to using a transformer as compared to simply
copying the bytes.  However, most updates to Jetty, JavaEmailServer, and
CrossFTP
transformed only a small fraction of heap objects.

% Current work versus plan for the future.
\paragraph{Current status}
For our current implementation of \DSU{}, we modified the following
components of \JikesRVM{}. We extended \JikesRVM{}'s signal-handling code
to recognize when a new update is available. We modified the VM's scheduler and
thread synchronization logic to hand control over to a designated VM thread
that will perform the dynamic update. This thread examines the
application's stacks to determine that the system is in a \emph{safe point}
for the update.  We enhanced the classloading framework to identify the new
classes and methods available for loading, load them and modify
datastructures to recognize the new versions and the correspondence between
them and the old version.  \DSU{}'s mechanism to transform individual
objects to correspond to their updated types is a significant modification
(explained in section~\ref{sec:xformers}) to \JikesRVM{}'s semi-space
copying collector.

\paragraph{Future work} The current implementation has several restrictions
on \emph{flexibility}: it limits which functions may be active when performing
the update. We propose the utilize \acf{OSR} support to update active
methods on the stack to allow more methods that can be active during the
update. \DSU{}'s current implementation requiring a single processor
machine poses another flexibility limitation. \DSU{} currently has a
dedicated DSU thread that is idle during normal execution of the program. A
signal from the user resumes this thread for DSU, and \DSU{} can perform
the update when this thread gains control of the processor. With
multiple processors, we propose to synchronize DSU threads (similar to how
GC threads synchronize) on all processors to ensure that all application
threads are suspended.  \DSU{}'s \emph{efficiency} is limited by the pause
time for an update.  Currently, object transformers require a
stop-the-world collector model, that performs full heap garbage collection.
This model suffers from long pause times making it undesirable for
real-time and/or highly available systems. These systems
typically employ concurrent garbage collectors. We propose to support dynamic
updates with such collectors.  Finally, we propose to have a more robust
iteration of \DSU{} and make a convincing argument in favor of dynamic
software updates by demonstrating it on a richer set of applications.

\paragraph{Thesis}
Our thesis is: \emph{\acf{DSU} in managed languages can be
achieved in a safe, flexible and efficient manner by naturally extending
existing VM services}. We make this claim by presenting \DSU{}, a VM-based
% In summary, the main contribution of this proposal is \DSU{}, a VM-based
approach for supporting dynamic software updating that is
distinguished from prior work in its realism, technical novelty, and
high performance.  We believe this approach is a substantial step
toward supporting highly flexible, efficient, and safe updates in
managed code virtual machines.  
%% The remainder of the paper first
%% compares our approach carefully to related work, and then describes
%% our model of updates, our implementation, and experimental results.

