\section{Overview}

A dynamic software update starts with an execution of the old version
of a program.  As the old version runs, program state is built up and
manipulated.  When a new version becomes available, this state is
migrated to the new version and execution continues with the
new-version code.  The aim is to achieve this conversion without
interrupting availability and while maintaining correctness.  Correct
dynamic update requires two main properties.  First, the \emph{state
  update function}, which performs the data migration, must properly
establish any invariants expected by the new version.  Secondly, the
update must occur at a point where any invariants assumed by the state
update function hold.  Generally this means that the update should not
occur in the middle of a low-level program operation, such as the
manipulation of a data structure or the processing of a network
request.  Points that are safe for update, where the expected
invariants hold, are referred to as \emph{quiescent points}.  Such
points can generally be identified statically and experience has shown
that permitting updates at only one or two static program points is
typically all that is needed~\cite{chris-tr}.  A natural choice for an
update point is at the beginning of a program's main event processing
loop.

Figure \ref{fig:hybrid} gives a graphical depiction of a trace through
a dynamically updated program.  The labels $a_1, a_2, a_3, a_4$
represent actions---for example events generated by a user's
interaction with the program's interface---while $\delta$ represents
the state update function mentioned previously, which performs the
migration of any persistent data from the old-version representation
to the new-version representation.  In the work described in this
paper, we assume that a static update point has been identified by the
programmer and concern ourselves with the inference of the state
update function $\delta$.  In order to infer $\delta$, we run each
version of the program using the same sequence of actions (as shown in
Figure \ref{fig:run-both}) and compare the resulting heaps.  If an
update is possible prior to each action $a_i$, then we would want to
consider all prefixes of the sequence of actions when performing this
inference.

\begin{figure}
%\begin{wrapfigure}[13]{r}{2.5cm}
\begin{center}
\begin{tikzpicture}
[circ/.style={draw,circle,minimum size=0.3cm},
 label distance=0.1cm,
 node distance=0.65cm]
\node[circ,label=left:\small Ver. 1] (a1) {};
\node[circ,right=of a1] (a2) {};
\node[circ,right=of a2] (a3) {};
\node[circ,below=of a3,label=left:\small Ver. 2] (b3) {};
\node[circ,right=of b3] (b4) {};
\node[circ,right=of b4] (b5) {};
\path (a1) edge[->,auto,swap] node {\small $a_1$} (a2);
\path (a2) edge[->,auto,swap] node {\small $a_2$} (a3);
\path (a3) edge[->,auto] node {\small $\delta$} (b3);
\path (b3) edge[->,auto,swap] node {\small $a_3$} (b4);
\path (b4) edge[->,auto,swap] node {\small $a_4$} (b5);
\end{tikzpicture}
\end{center}
\caption{\label{fig:hybrid}Trace of an updated program.}
%\end{wrapfigure}
\end{figure}

\begin{figure}
%\begin{wrapfigure}[13]{r}{2.5cm}
\begin{center}
\begin{tikzpicture}
[circ/.style={draw,circle,minimum size=0.3cm},
 label distance=0.1cm,
 node distance=0.65cm]
\node[circ,label=left:\small Ver. 1] (a1) {};
\node[circ,right=of a1] (a2) {};
\node[circ,right=of a2] (a3) {};
\node[circ,below=of a1,label=left:\small Ver. 2] (b3) {};
\node[circ,right=of b3] (b4) {};
\node[circ,right=of b4] (b5) {};
\path (a1) edge[->,auto,swap] node {\small $a_1$} (a2);
\path (a2) edge[->,auto,swap] node {\small $a_2$} (a3);
\path (a3) edge[<->,densely dashed,auto] node {\small compare} (b5);
\path (b3) edge[->,auto,swap] node {\small $a_1$} (b4);
\path (b4) edge[->,auto,swap] node {\small $a_2$} (b5);
\end{tikzpicture}
\end{center}
\caption{\label{fig:run-both}Comparing the heaps produced by two test runs.}
%\end{wrapfigure}
\end{figure}

\subsection{JavaEmailServer Example}

The change is in the code that reads the user configuration file.
This file is a set of key, value pairs, one of which is a list of
addresses to forward to this user.

\subsubsection{Common Code}

The code below did not change between versions, but is referenced by
the code that did change.

\begin{lstlisting}
public class EmailAddress implements Serializable {
    public EmailAddress() { _isEmpty = true; }
    ...
    private String _username = "";
    private String _domain = "";
    private boolean _isEmpty = false;
}   
\end{lstlisting}

This User class is filled in by \code{ConfigurationManager.loadUser(...)}
It is this function that changed between versions.

\subsubsection{Old Version}
\begin{lstlisting}
public class ConfigurationManager
  implements ConfigurationParameterContants {
    ...
    private User loadUser( String fullAddress, Properties properties )
                   throws InvalidAddressException
    {   ...
        // Load the 'forward' addresses.
        String forwardAddressesString =
          properties.getProperty( USER_PROPERTY_PREFIX + fullAddress 
                                + USER_FILE_FORWARDS );
        String[] forwardAddresses = new String[0];
        if( forwardAddressesString != null 
         && forwardAddressesString.trim().length() == 0 )
        {
            forwardAddresses = tokenize( forwardAddressesString );
        }
        user.setForwardAddresses( forwardAddresses );
        ...
    }
}
\end{lstlisting}

\begin{lstlisting}
public class User {
    private String username;
    private String domain;
    private String password;
    private String[] forwardAddresses;
    ...
}
\end{lstlisting}

\subsubsection{New Version}

\begin{lstlisting}
public class ConfigurationManager
  implements ConfigurationParameterContants {
    ...
    private User loadUser( String fullAddress, Properties properties )
                   throws InvalidAddressException
    {   ...
        // Load the 'forward' addresses.
        String forwardAddressesString =
          properties.getProperty( USER_PROPERTY_PREFIX + fullAddress 
                                + USER_FILE_FORWARDS );
        String[] forwardAddresses = new String[0];
        if( forwardAddressesString != null 
         && forwardAddressesString.trim().length() >= 0 )
        {
          forwardAddresses = tokenize( forwardAddressesString );
        }
        ArrayList addressList = new ArrayList( forwardAddresses.length );
        for( int index = 0; index < forwardAddresses.length; index++ ) {
            try {
              addressList.add( new EmailAddress( forwardAddresses[index] ));
            }
            catch (InvalidAddressException e) {
              log.warn( "Forward address: " + forwardAddresses[index]
                        + " for user " + user.getFullUsername()
                        + " is invalid and will be ignored." );
            }
        }

        EmailAddress[] emailAddresses = new EmailAddress[ addressList.size() ];
        emailAddresses = (EmailAddress[]) addressList.toArray( emailAddresses );

        if( log.isDebugEnabled() ) 
          log.debug( emailAddresses.length
                   + " forward addresses load for user: "
                   + user.getFullUsername() );
        user.setForwardAddresses( emailAddresses );
        ...
    }
}
\end{lstlisting}

\begin{lstlisting}
public class User {
    private String username;
    private String domain;
    private String password;
    private EmailAddress[] forwardAddresses;
    ...
}
\end{lstlisting}


\subsubsection{Update}

Suppose a user John has the following list of forwarded addresses
defined.
\begin{verbatim}
john@umd.edu, john@cs.umd.edu, jb@user-desktop.cs.umd.edu
\end{verbatim}
Prior to the change, this configuration would result in the
\texttt{user.forwardAddresses} field of the User class instance for
John having the following value (and array of String objects).

\texttt{["john@umd.edu", "john@cs.umd.edu", "jb@john-desktop.cs.umd.edu"]}

Post-update, the \texttt{user.forwardAddresses} field of the User
class instance for John has the type EmailAddress[] and has the
following value.

\texttt{[o1, o2, o3]}

where \texttt{o1, o2, o3} are references to EmailAddress objects with
the following field values.

\begin{verbatim}
o1._username = john
o1._domain = umd.edu
o1._isEmpty = false

o2._username = john
o2._domain = cs.umd.edu
o2._isEmpty = false

o3._username = jb
o3._domain = john-desktop.cs.umd.edu
o3._isEmpty = false
\end{verbatim}

The generated transformer would be:

\begin{align*}
\lambda o.\ \lambda n.\ &n.\textsf{\_username} := \substr(o,0);\\ &n.\textsf{\_domain} := \substr(o,1);\\ &n.\textsf{\_isEmpty} := \textsf{false}
\end{align*}

\subsection{Azureus Example}

\lstset{
  numbers=left,numberstyle=\em\scriptsize,numbersep=5pt,
  basicstyle=\sffamily,columns=flexible,mathescape=true,
  lineskip=1pt,frame=single,escapeinside={/**}{*/},upquote=false,
  escapechar=|
}

\begin{figure}
\begin{minipage}{\textwidth/2}
\begin{center}
Old Version
\end{center}
\begin{verbatim}
  public class PEPeerControlImpl
         implements PEPeerControl, ParameterListener
  {
    public void stopAll() {
      ...
      _bContinue = false;
      _server.stopServer();
     ...
    }
  }

  public class PESharedPortServerImpl

\end{verbatim}
\end{minipage}
\begin{minipage}{\textwidth/2}
\begin{center}
New Version
\end{center}
\begin{verbatim}
  public class PEPeerControlImpl
         implements PEPeerControl, ParameterListener
  {
    public void stopAll() {
      ...
      //3. Stop the server
      _server.stopServer();

      _server.clearServerAdapter();
      ...
    }
  }

  public class PESharedPortServerImpl
         implements PEPeerServerHelper
  {
    public void
    clearServerAdapter()
    {
      adapter = null;
    }
  }
\end{verbatim}
\end{minipage}
\caption{\label{fig:azureus-change}A change that fixes a memory leak in a 2004 version of Azureus.}
%\end{wrapfigure}
\end{figure}

One application we consider in our experiments is Azureus, a
bittorrent client written in Java.  Bittorrent is a peer-to-peer file
transfer protocol and Azureus is a very mature implementation of the
protocol, having been in development for eight years.  Figure
\ref{fig:azureus-change} gives an example of a change that was made to
an early version of the client (March 2004).  The application
maintains a server object for each file being transferred, and this
server object includes a field, \texttt{adapter}, that points to the
information associated with the download, such as the download status,
the average speed, and connections to other peers that are serving the
file.  When a download is stopped, this information is no longer
necessary and should be garbage collected.  However failure to write a
null to the \texttt{adapter} field in the old version prevents this
collection from happening.  In the new version, the call to
\texttt{stopServer()} is immediately followed by a call to
\texttt{clearServerAdapter()}, which was absent in the old version.
This writes \texttt{null} to the \texttt{adapter} field allowing the
adapter object to be garbage collected.

Before \texttt{stopServer()} is called, a private flag
\texttt{\_bContinue} is set to \texttt{false}, and the status of this
flag can be used to determine whether a download is currently active.
The desired state update function is then the code given in Figure
\ref{fig:leak-1-state-update}.  Identifying this function by hand
requires careful analysis of the code in order to ascertain the
connection between the code change (inserting the
\texttt{clearServerAdapter()} call) and the state (the
\texttt{\_bContinue} flag and the value of the \texttt{adapter}
field).  In the remainder of this section, we give an overview of how
our approach can be used to automatically infer the update function
from program test cases.

\begin{figure}
\begin{verbatim}
if(old._server._bContinue == false)
  new._server.adapter = null
else
  new._server.adapter = old._server.adapter
\end{verbatim}
\caption{\label{fig:leak-1-state-update}The state update function for the Azureus leak.}
%\end{wrapfigure}
\end{figure}

\subsection{Snapshotting}

As indicated by Figure \ref{fig:run-both}, we start by running each
version of the program and providing them with the same set of
actions.  We call an execution with a fixed set of actions a
\emph{test run}.  In Azureus, there are a number of events that could
potentially qualify as an ``action.''  There are network-level events,
such as opening a socket or initiating a connection.  There are
protocol-level events such as listing the pieces of a file that each
peer is providing.  And there are user-level events such as adding,
stopping, and resuming file downloads.  It is the latter that we take
as the notion of ``action'' for Azureus.

The choice of what set of events to consider when performing test runs
will vary by application and may be constrained by the runtime
environment.  For example, even if we wanted to use network-level
events as our notion of action, the Oracle JVM does not provide
support for capturing and replaying low-level network events.  The
inability to precisely replay network traffic causes the heaps
produced by two test runs to differ more than they would if we had
more precise control over the application's execution.  However, we
have developed techniques to address this and we believe that the
ability to use a stock VM is an important feature of our approach.

Once the notion of action has been determined, a test script can be
written to execute these actions.  For Azureus, this script starts and
stops a series of downloads.  If an application provides test scripts,
unit tests, or regression tests, these can also be used to generate an
action sequence.  As we mentioned previously, we assume that an update
point has already been marked in the source code by the programmer.
In our experiments, this location is marked by a call to a static
\texttt{permitUpdate()} function.  When performing the test run, we
link in a version of \texttt{permitUpdate()} that makes no changes to
the code, but instead simply dumps the entire heap to a file.  We call
a heap dump associated with an update point a \emph{snapshot}.

In the case of Azureus, we use the console interface to perform the
test run and snapshots occur whenever the interface reads a new line
of input from the console.  Thus, an update can occur between any two
high-level commands (start download, stop download, etc.) and given a
test script with $n$ commands, we obtain $n$ snapshots for each
program version.  Once we have these, we then compare the
$i^\text{th}$ snapshot from version 1 with the $i^\text{th}$ snapshot
from version 2 in order to infer the state update function.  In our
example, we are transforming objects of type
\texttt{PEPeerControlImpl} and our snapshots will contain one instance
of this class for each download.

\subsection{Matching}

We next describe how we compare heaps.  The idea is to identify
\emph{input / output examples} which we can use to guide the synthesis
of the state update function.  This requires matching
``corresponding'' objects from the version 1 and version 2 heaps.  Two
objects $o_1,o_2$ \emph{correspond} if they serve the same role.  For
example, in Azureus there is one \texttt{PEPeerControlImpl} instance
per download.  Thus, two \texttt{PEPeerControlImpl} objects correspond
if and only if they are associated with a download of the same file.
Often, corresponding objects will have certain fields whose values
match.  We call these \emph{key fields}.  In the Azureus example,
\texttt{PEPeerControlImpl} has a field \texttt{nbPieces} that records
the number of file pieces, which is proportional to the size of the
file to be downloaded.  If the files being downloaded differ
sufficiently in size, this can be used to match objects from version 1
and version 2.  If we permit ourselves to dereference fields more than
once when searching for keys, we can use
\texttt{PEPeerControlImpl.\_diskManager.fileName}, which gives the
name of the file being downloaded, and will thus be different even for
files with the same size.  We can take the combination of the two
fields to enable us to match objects even more precisely.  We call
this process of finding input / output examples \emph{matching}.

Suppose we choose the file name as a key and consider a point in the
test run where four downloads have been initiated (with filenames
\texttt{file1.dl} through \texttt{file4.dl}), but two of those were
stopped (\texttt{file1.dl} and \texttt{file2.dl}).  In this case, we
have four \texttt{PEPeerControlImpl} instances, each with different
file names.  If we pair the instances from the old and new-version
test runs based on the file name field, we obtain four pairs that
serve as input-output examples for the state update function we want
to synthesize.

\subsection{Synthesis}

We can now search for an update function for the field of interest.
In our example, the field affected by the code change was
\texttt{\_server.adapter}.  Figure \ref{fig:example-pairs} lists the
four pairs of objects that are produced by the matching phase.  If we
examine these, we find that for the two downloads that were stopped,
\texttt{\_server.adapter} is \texttt{null}.  For the other two pairs,
the \texttt{\_server.adapter} field is unchanged.  If \texttt{old}
refers to the old instance and \texttt{new} refers to the new object
instance, we obtain two update functions: \texttt{old.\_server.adapter
  = null} and \texttt{old.server.adapter = new.server.adapter}.
\begin{figure}
\lstset{linewidth=3.8cm, numbers=none}
\newcommand{\qq}{\texttt{\symbol{34}}}
\newcommand{\fname}[1]{``\,{#1}\,''}
\begin{minipage}{3.8cm}
\begin{lstlisting}
$\texttt{\_}$bContinue : false
$\texttt{\_}$diskManager : ...
  fileName : |\fname{file1.dl}|
$\texttt{\_}$nbPieces : 1390
$\texttt{\_}$server :
  adapter : 0x108139668
\end{lstlisting}
\end{minipage}
\begin{minipage}{\textwidth / 2}
\begin{lstlisting}
$\texttt{\_}$bContinue : false
$\texttt{\_}$diskManager : ...
  fileName : |\fname{file1.dl}|
$\texttt{\_}$nbPieces : 1390
$\texttt{\_}$server :
  adapter : null
\end{lstlisting}
\end{minipage}
\begin{minipage}{\textwidth / 2}
\begin{lstlisting}
$\texttt{\_}$bContinue : false
$\texttt{\_}$diskManager : ...
  fileName : |\fname{file2.dl}|
$\texttt{\_}$nbPieces : 1651
$\texttt{\_}$server :
  adapter : 0x10811c1a0
\end{lstlisting}
\end{minipage}
\begin{minipage}{\textwidth / 2}
\begin{lstlisting}
$\texttt{\_}$bContinue : false
$\texttt{\_}$diskManager : ...
  fileName : |\fname{file2.dl}|
$\texttt{\_}$nbPieces : 1651
$\texttt{\_}$server :
  adapter : null
\end{lstlisting}
\end{minipage}
\begin{minipage}{\textwidth / 2}
\begin{lstlisting}
$\texttt{\_}$bContinue : true
$\texttt{\_}$diskManager : ...
  fileName : |\fname{file3.dl}|
$\texttt{\_}$nbPieces : 1387
$\texttt{\_}$server :
  adapter : 0x108042848
\end{lstlisting}
\end{minipage}
\begin{minipage}{\textwidth / 2}
\begin{lstlisting}
$\texttt{\_}$bContinue : true
$\texttt{\_}$diskManager : ...
  fileName : |\fname{file3.dl}|
$\texttt{\_}$nbPieces : 1387
$\texttt{\_}$server :
  adapter : 0x108042848
\end{lstlisting}
\end{minipage}
\begin{minipage}{\textwidth / 2}
\begin{lstlisting}
$\texttt{\_}$bContinue : true
$\texttt{\_}$diskManager : ...
  fileName : |\fname{file4.dl}|
$\texttt{\_}$nbPieces : 2837
$\texttt{\_}$server :
  adapter : 0x10822c230
\end{lstlisting}
\end{minipage}
\begin{minipage}{\textwidth / 2}
\begin{lstlisting}
$\texttt{\_}$bContinue : true
$\texttt{\_}$diskManager : ...
  fileName : |\fname{file4.dl}|
$\texttt{\_}$nbPieces : 2837
$\texttt{\_}$server :
  adapter : 0x10822c230
\end{lstlisting}
\end{minipage}
\begin{minipage}{\textwidth / 2}
\ \ \ 
\end{minipage}
\caption{\label{fig:example-pairs}The input / output example pairs produced by the matching phase.}
\end{figure}

Now we need some method of determining which function to apply to an
object.  To do this, we search for a boolean condition over
old-version fields that holds for those example pairs to which the
\texttt{new.\_server.adapter = null} update applies, but does not hold
for the \texttt{new.\_server.adapter = old.\_server.adapter} update.
In this case, the only condition satisfying this is
\texttt{old.\_server.\_bContinue = false} and so we obtain the update
below.
\begin{verbatim}
if(old._server._bContinue == false)
  new._server.adapter = null
else
  new._server.adapter = old._server.adapter
\end{verbatim}

Performing this synthesis task for the remaining fields gives us a
full update function that applies to any instance of
\texttt{PEPeerControlImpl}.

\subsection{Complications}

We have elided some aspects of the procedure that make synthesis less
straightforward.  One issue is that some fields inevitably vary
between runs of the program.  Examples of these are timestamps and
random number seeds.  These can be detected by performing two test
runs at the old version and comparing those heaps.

Object references pose another complication.  In the example pairs in
Figure \ref{fig:example-pairs}, we listed the same address for
\texttt{\_server.adapter} in both the old and new versions when that
field was not overwritten with \texttt{null}.  In an actual run, the
address assigned to any object will be non-deterministic.  However, if
two addresses from separate runs point to corresponding objects, we
should consider those addresses to be the same.  We leverage our
matching infrastructure to determine when objects correspond and we
consider addresses of corresponding objects to be equal.

We also sometimes end up with a different number of objects being
allocated in each test run.  For example, in Azureus there is a class
that represents a connection to a peer.  When performing two test runs
involving a file download, the exact peers to which the client
connects will vary.  However, most peers will appear in both runs and
we can use this fact to enable us to still perform matching and
synthesis.

We give more details on how these complications are handled in the
remainder of the paper.
